\anonsection{Обзор предметной области}

	Сопрограмма (с английского coroutine) — программная компонента, особым образом организованная для обеспечения взаимодействия с другими компонентами по принципу кооперативной многозадачности. Выполнение модуля может быть приостановлено в определённой точке и предано другой сопрограмме. При этом будет сохранено полное состояние сопрограммы (включая стек, значения регистров и счётчик команд).
	\par
	Концепция сопрограмм не нова: впервые они появились в языках программирования Симула,
	Модула-2 в 1960-е — 1970-е годы и использовались как еще одно языковое средство для
	реализации итераторов, генераторов, бесконечных списков и так далее. К сожалению, в
	тот момент концепция не получила широкого распространения и в более поздних языках
	программирования, таких как Си, С++, Java, она не была применена. Если нужна
	альтернатива сопрограммаам, то рекомендовалось использовать потоки. 
	%В случае языков Си и С++ можно применять системные функции для переключения контекста %для реализации сопрограмм в виде библиотеки.
	\par
	Начиная где-то с 2010-го года все стало стремительно меняться. Программы все это время
	росли и появилась проблема масштабируемости таких приложений. Одним из способов
	масштабирования программ это параллелизм: если хотим обработать кусок данных, который
	может быть достаточно крупным, то мы можем распределить его обработку на несколько потоков. Но есть другой, более сложный и распространенный
	вид масштабирования, который касается одновременной обработки
	относительно независимых задач, требуемых от приложения - конкуренция(с англ. concurrency). То, что они должны обслуживаться одновременно, - это не выбор реализации, а требование.
	\par
	Рассмотрим на примере веб-сервера. Каждый из запросов, которые он обслуживает, в значительной степени
	независим от других. Для каждого из них выполняется синтаксический анализ пакета, делается запрос к базе данных и/или к другому серверу, формируется ответ, который
	отправляется в клиенту. Каждый запрос не взаимодействует с другими одновременными
	HTTP-запросами, но они конкурирует с ними за процессорное время и ресурсы ввода-вывода.
	%ins examples
	Каждое параллельное приложение имеет 
	некоторые единицы параллелизма, естественные для его области, причем исполнение 
	некоторой работы выполняется независимо от другой в то же время. Для 
	веб-сервера это может быть HTTP-запрос; для базы данных это может быть транзакция.
	
	Проблема заключается в том, что поток, программная единица параллелизма, не может соответствовать масштабу
	естественных единиц параллелизма приложения - пользовательского сеанса, HTTP-запроса или транзакция в базу
	данных. Сервер может обрабатывать до миллиона одновременных открытых сокетов, но операционная система не
	может эффективно обрабатывать более нескольких тысяч активных (не бездействующих) потоков. 
	Забавно, что потоки были придуманы для виртуализации скудных вычислительных ресурсов с целью совместного
	использования, сами стали дефицитными ресурсами. Поскольку создание новых потоков дорогостоящая операция,
	их объединяют в пул для дальнейшего переиспользования. 
	
	К сожалению, пул предлагает слишком грубый механизм разделения потоков. Часто в пуле просто недостаточно
	потоков для представления всех независимых задач, выполняемых одномоментно. Заимствование потока OC из
	пула на все время выполнения задачи удерживает поток, даже когда он ожидает какого-либо внешнего события,
	например, ответ от базы данных, сервера, или любого другого действия, которое может его заблокировать.
	Потоки ОС слишком важны, чтобы за них можно было держаться, когда задача просто ждет. Чтобы совместно
	использовать потоки более точно и эффективно, стоило бы возвращать поток в пул каждый раз, когда задача
	должна ждать некоторого результата. Это означает, что задача больше не привязана к одному потоку для всего
	своего выполнения. Это также означает, что мы должны не допускать блокировки потока, потому что такой
	поток станет недоступен для любой другой работы.
	\par
	Решением проблемы является использование асинхронного API и неблокирующего ввода/вывода. Эти  механизмы
	позволяют вернуть поток в пул, пока задача ждет результата операции. Программы, реализованные в таком
	стиле сложнее отлаживать, профилировать и искать в них ошибки. Но по другому поступить нельзя, если нужно
	удовлетворить требование масштабируемости приложения и необходимо эффективно использовать текущие
	аппаратные ресурсы. Некоторые языки программирования борятся со сложностями асинхронного кода.
	
	\subsection{Котлин и C\#}
	В языках программирования JavaScript и C\# реализовали концепцию "async/await".
	
	\subsection{Язык Go}
	
	\subsection{Проект "Loom"}
	
	
\clearpage