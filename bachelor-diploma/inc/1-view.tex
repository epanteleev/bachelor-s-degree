\section{Обзор предметной области}
	\subsection{Что такое Сопрограммы?}
	Сопрограммы (англ. coroutine) — программный модуль, особым образом организованный для обеспечения взаимодействия с другими модулями по принципу кооперативной многозадачности \cite{coroutine}. Выполнение сопрограммы может быть
	приостановлено в точках явного планирования и предано другому модулю. Выполнение модуля может быть приостановлено в
	определённой точке и предано другой сопрограмме. При этом будет сохранено полное состояние сопрограммы (включая
	стек, значения регистров и счётчик команд).
	\par
	Концепция сопрограмм не нова: впервые они появились в языках программирования Симула\cite{simula},
	Модула-2\cite{modula} в 1960-е — 1970-е годы и использовались как еще одно языковое средство для
	реализации итераторов, генераторов, бесконечных списков и так далее. В
	тот момент концепция не получила широкого распространения и в более поздних языках
	программирования, таких как Си, С++, Java, она не была применена. Если нужна
	альтернатива сопрограммаам, то использовались потоки. В случае языков Си и С++ можно применять 
	системные функции для переключения контекста потока для реализации сопрограмм в виде библиотеки.
	\par
	Сопрограммы по своему поведению, очень похожи на потоки операционной системы: они могут сохранять
	контекст\footnote{Контекст - регистры и указатель на стек потока или сопрограммы.} и при
	останавливать свое выполнения. Но есть ряд существенных отличий:
	\begin{enumerate}
		\item Переключение сопрограммы происходит в пользовательском пространстве операционной системы в отличие от потоков, которые
		управляются ядром ОС. Кроме того, сопрограммы являются объектом среды исполнения языка, что позволяет оптимизировать переключение
		контекста под конкретный язык и виртуальную машину. В сумме эти два фактора позволяют уменьшить накладные расходы на переключение
		потока выполнения. Как итог, системы, построенные на сопрограммаах, будут иметь лучшее время отклика, чем те, которые используют
		только потоки.
		\item Сопрограммы как правило имеют меньший размер стека. Как говорилось в прошлом пункте,
		сопрограммы являются сущностями среды исполнения в отличии от потоков, а значит виртуальная машина имеет больший
		контроль над стеком первых. Потому появляется возможность выделять сравнительно небольшие стеки под сопрограммы. 
		Если он переполняется, то виртуальная машина может создать новый стек большего размера и содержимое старого копируется в новый. Благодаря меньшему
		размеру стека, виртуальная машина способна создавать число сопрограмм, превосходящее по количеству потоков OC на той же аппаратуре.
		\item Известно, что при операциях ввода/вывода вызывающий поток блокируется операционной системой\cite{linux-api}.
		Это делается во избежание лишнего простоя процессора, который в момент работы вызова ввода/вывода может
		переключится на выполнение другой задачи, которую запланирует ядро ОС. Сопрограммаами  же управляет среда
		исполнения языка, которая способна вытеснить сопрограмму, инициирующую операцию ввода вывода, избежав при
		этом блокировки потока. Если закрепить за потоком ядро процессора и запретить операционной системе вытеснять
		его, то возможно техника блокирование сопрограмм даст прирост производительности.
		\item В отличии от потоков, сопрограммы планируются средой исполнения языка. Это дает огромный плюс. 
		Благодаря этому, разработчику приложения дается возможность оптимизировать планировщик сопрограмм
		под конкретную задачу.
	\end{enumerate}
	
	Сопрограммы уже поддерживаются многими языками программирования, такими как С++ стандарта 20, С\#, JavaScript,
	Go и многие другие. Эти языки используют различные подходы к реализации сопрограмм. В следущих разделах 
	рассмотрим способы переключения в управляемых средах.
	
	\subsection{JavaScript и C\#}
	В JavaScript для работы с асинхронным вводом выводом введен класс Promise.
	Он представляет собой обёртку для значения, неизвестного на момент создания объекта. 
	Promise позволяет обрабатывать результаты асинхронных операций так, как если бы они были синхронными:
	вместо результата асинхронного метода возвращается обещание получить результат в будущем.
	Для удобной работы с Promise (c Task в случае С\#), существует специальный синтаксис, который называется «async/await».
	
	\begin{lstlisting}
		async function f() {
			return 100;
		}
	\end{lstlisting}

	Ключевое слово async перед функцией означает, что функция всегда возвращает Promise.
	
	\begin{lstlisting}
		let value = await promise;
	\end{lstlisting}
	Ключевое слово await заставляет ждать, пока Promise не исполнится, и возвращает результат операции. Это работает только в функциях, помеченных ключевым словом async. 
	
	Механизм async/await работает как потоки, но точки совместного планирования явно отмечены значком
	await. Это позволяет писать масштабируемый синхронный код и решает проблему контекста, вводя
	его	новый вид, который представляет собой поток во всем, но несовместим с потоками операционной
	системы. Синхронный и асинхронный код обычно не могут быть смешаны в одином блоке кода, и в
	результате языки с поддержкой async/await требуют два разных API для приостановки выполнения async
	блока кода и текущего потока. В Kotlin существует таже самая проблема: один API предназначен для
	приостановки потока, а другой для остановки новой конструкции, которая похожа на поток, но не
	является им.
	
	\subsection{Язык Go}
	Сопрограммы в Go еще называют горутинами. Это функции, которые запускаются конкурентно с другими функциями. 
	При запуске новой сопрограммы нужно перед вызываемой функцией вставить ключевое слово \textbf{go}.
	
	\begin{lstlisting}
	package main
	import "fmt"
	
	func foo() {
		fmt.Println("Foo called.")
	}
	func bar() {
		fmt.Println("Bar called.")
	}
	func main() {
		go foo()
		go bar()
	}

	\end{lstlisting}
		
	Эта программа содержит 3 сопрограммы. Первая - это функция main, являющаяся
	неявной сопрограммой. Вторая и третья это foo и bar. Обычно при вызове функции, наша программа 
	выполняет все ее операторы, а затем возвращает управление на следующую строку после вызова. 
	С помощью сопрограммы управление немедленно переходит к следующей строке без необходимости дожидаться завершения функции. Cреда исполнения языка не позволяет использовать потоки операционной системы
	напрямую. Разрешается создавать только сопрограммы.
	\par
	Язык Go, начиная с версии 1.3 использует непрерывный стек корутин. В прологе вызываемой функции вставляется проверка,
	что текущего размера стека будет достаточно для исполнения кода. Если старый стек слишком мал,
	то выделяется память под новый стек и содержимое старого копируется в новый. Имеющиеся указатели на
	данные в с стеке изменяются на новые. Данная реализация позволяет иметь небольшие стеки порядка 4-8кБ, которые
	могут расти в неограниченных пределах. Но проверка выхода за границы размера в прологе дает накладные расходы,
	что является минусом.
	\par 
	Механизм переключение контекста сопрограммы в языке Go похож на переключения потоков[kernel.org???]:
	сохраняются в отдельный буфер необходимые регистры и информация, характерная только для данного
	потока/горутины, а затем в указатель стека записывается другой адрес. Но в отличии от потоков, 
	при переключении сопрограммы Go выполняется меньше операций и сохраняются не все регистры\cite{go-context}.
	
	\subsection{Проект "Loom"}
	В текущей версии языка Java - JDK16, поддержка сопрограмм отсутствует. Но с конца 2017 года ведется 
	работа в этом направлении проектом "Loom". Он направлен на сокращение усилий по написанию, поддержке
	высокопроизводительных параллельных приложений, которые максимально используют доступное оборудование\cite{loom-main}.
	\par
	Сопрограммы Loom - это виртуальные потоки, создание и блокировка которых требует меньше накладных расходов\cite{loom-main}. Они управляются средой исполнения языка Java. 
	В отличие от представленных в стандартной библиотеке потока "java.lang.Thread", виртуальные потоки не являются
	оболочками потоков ОС, а реализованы в JDK.
	
	\par
	Loom использует другой подход к переключению сопрограмм, отличающийся от языка Go. Когда сопрограмма начинает
	свою работу, она использует стек потока, на котором она запущена. При переключении сопрограммы происходит
	копирование части стека, используемой сопрограммой, в отдельный буфер памяти. Если нужно передать 
	управление обратно в сопрограмму, то происходит опустошение буфера и копирование его содержимого на 
	вершину стека потока\cite{loom-main}. Такая техника выбрана в целях совместимости со всеми существующими 
	сборщиками мусора, которые есть в OpenJDK. Некоторые из них не могут поддерживать объекты на куче, которые
	могут хранить ссылки по смещениям в памяти, меняющиеся на протяжении всего времени существования объекта
	на куче.

	\subsection{Применение сопрограмм}
	Сопрограммы имеют ряд практических применений. При появлении они использовались как средство
	для создания генераторов, итераторов, бесконечных списков и так далее. 
	
	C недавнего времени, с помощью сопрограмм стали реализовывать структурированный параллелизм: 
	управление разделяется на параллельные задачи, они снова объединяются. 
	Если основная задача разбивается на несколько параллельных подзадач, которые должны выполняться
	порожденными сопрограммы, завершающиеся до основной задачи. Вызывающий
	метод не должен заботиться о том, разбивает ли метод работу на подзадачи, которые выполняются 
	миллионом сопрограмм. Когда метод завершается, все сопрограммы, запланированные методом, должны
	быть завершены.
	
	Сопрограммы подходят для работы со множеством относительно независимых задач.
	\par
	Рассмотрим на примере http-сервера. Каждый из запросов, которые он обслуживает, в значительной
	степени независим от других. Для каждого из них выполняется синтаксический анализ пакета, делается
	запрос к базе данных и/или к другому серверу, формируется ответ, который отправляется в клиенту. 
	Каждый запрос не взаимодействует с другими одновременными HTTP-запросами, но они конкурирует с ними за процессорное время и ресурсы ввода-вывода.
	Другими словами, http-сервер имеет некоторые единицы параллелизма домена приложения, 
	специфичные для его области, причем исполнение некоторой задачи выполняется независимо от другой в
	то же время. В данном случае единицей параллелизма является http-запрос. Для базы данных это может
	быть транзакция.
	\par
	Проблема заключается в том, что поток, не может соответствовать масштабу единиц параллелизма домена приложения.
	Потенциально сервер может обрабатывать до миллиона
	одновременных открытых сокетов, но операционная система не может эффективно обрабатывать более нескольких
	тысяч не бездействующих потоков.
	\par
	Сопрограммы позволяют избежать такую проблему. В силу своих преимуществ, их может быть
	созданно несколько миллионов, в то время как операционная система может поддерживать всего 
	лишь несколько тысяч активных потоков. В добавок они уменьшают время отклика сервера из--за
	большей скорости переключения.
	\par
	Кроме того, сопрограммы позволяют легко организовать работу с асинхронным  кодом.
	Неблокирующие операции, в том числе и асинхронный ввод--вывод, строится на обратных обработчиках.
	Когда такого кода очень много, его становится очень трудно отлаживать и исправлять.
	Сопрограммы помогают избежать такой проблемы, представляя список обработчиков как
	последовательный кусок кода.
	
\clearpage