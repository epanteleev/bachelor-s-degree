\section{Обзор предметной области}
	\subsection{Java в параллельных системах}
	В современном мире язык Java используется для создания крупных многопоточных приложений 
	для решения многих задач, в том числе и научных. Начиная с 90-x годов, Java используется для реализации
	систем управления Большим адронным коллайдером и для организации параллельной обработки результатов 
	экспериментов, например, в библиотеке Colt Parallel\cite{colt}. Язык Java выбран из-за того, что он 
	обладает управляемой средой исполнения, a это значительно упрощает разработку. Управляемая среда представляет
	собой вычислительное окружение, необходимое для настройки стека и кучи, включающее в себя функции сборки мусора,
	синхронизации потоков и так далее.
	\par
	Традиционно, параллелизм реализуется внутри операционной системы с помощью механизма потоков, 
	которые абстрагируют иногда взаимодействующие между собой независимо работающие задачи. 
	Поток (от англ. thread) -- наименьшая единица обработки, исполнение которой может 
	быть запланировано ядром операционной системы\cite{thread}.
	В современных реалиях их количество обычно превышает число ядер процессора: 
	аппаратного механизма параллелизма. Операционным системам следует представлять потоки
	как универсальное средство многозадачности для всех ныне существующих языков программирования. Потому потоки 
	-- это достаточно "тяжеловесный" механизм: их создание и переключение несет в себе крупные накладные расходы. 
	Это становится особенно заметно c ростом числа потоков в программе. 
	\par
	Но существует возможная альтернатива потокам -- сопрограммы.
	
	\subsection{Что такое Сопрограммы?}
	Сопрограммы (англ. coroutine) — программный модуль, особым образом организованный для обеспечения взаимодействия с другими модулями по принципу кооперативной многозадачности\cite{coroutine}. Выполнение сопрограммы может быть
	приостановлено в точках явного планирования и предано другому такому модулю. При этом будет сохранено полное
	состояние сопрограммы: включая стек, значения регистров и счётчик команд.
	\par
	Концепция сопрограмм не нова: впервые они появились в языках программирования Симула\cite{simula},
	Модула-2\cite{modula} и Клу\cite{clu} в 1960 — 1970-е годы и использовались как еще одно языковое средство для
	реализации итераторов, генераторов, бесконечных списков и так далее. В
	тот момент концепция не получила широкого распространения и в более поздних языках
	программирования, таких как Си, С++, Java, она не была применена. Если нужна была
	альтернатива сопрограммаам, то использовались потоки. В случае языков Си и С++ можно применять функции для
	переключения контекста потока для представления модуля сопрограмм в виде библиотеки.
	\par
	Что касается реализации, то часто сопрограммы исполняются специально выделенными потоками операционной системы,
	как это применяется в языке Go. С точки зрения пользователя языка они являются обычными потоками.
	И это не удивительно, ведь сопрограммы, как говорилось ранее, могут сохранять контекст\footnote{Контекст -- регистры и указатель на стек потока или сопрограммы.} и приостанавливать поток вычисления, что свойственно и потокам. Но есть ряд существенных отличий:
	\begin{enumerate}
		\item Переключение сопрограммы происходит в пользовательском пространстве операционной системы в отличие от
		потоков, которые планируются ядром ОС. Сопрограммы являются объектом среды исполнения языка, что
		позволяет оптимизировать переключение контекста под конкретный язык и виртуальную машину. Это уменьшает
		накладные расходы на переключение их потока выполнения. Как итог, системы, построенные на сопрограммаах, будут
		иметь лучшее время отклика и лучше масштабируются.
		\item Сопрограммы как правило имеют меньший размер стека. Как говорилось в прошлом пункте,
		сопрограммы являются сущностями среды исполнения в отличии от потоков, а значит виртуальная машина имеет больший
		контроль над ними. Потому появляется возможность выделять сравнительно небольшие стеки под сопрограммы. 
		Если он переполняется, то виртуальная машина может создать новый стек большего размера и содержимое старого
		скопировать в новый. Благодаря меньшему размеру стека, виртуальная машина способна создавать число
		сопрограмм, превосходящее по количеству потоков OC на том же оборудовании.
		\item Известно, что при вызове блокирующих операций, вроде приема данных из сети, вызывающий поток вытесняется
		операционной системой\cite{linux-api}. Это делается во избежание лишнего простоя процессора, который в момент
		работы блокирующего вызова может переключится на выполнение другого потока, запланированного ядром операционной
		системы. Сопрограммаами же управляет среда исполнения языка, которая способна вытеснить сопрограмму,
		инициирующую операцию ввода вывода, избежав при	этом блокировки потока. Если бы была возможность запретить
		вытеснение по таймеру потоков, которые исполняют сопрограммы, то возможно техника блокирование сопрограмм даст прирост производительности.
		\item В отличии от потоков, сопрограммы планируются средой исполнения языка. Благодаря этому, разработчику
		приложения дается возможность оптимизировать планировщик сопрограмм	под конкретную задачу, что не возможно в
		системах, построенных на потоках.
	\end{enumerate}
	Сопрограммы уже поддерживаются многими языками программирования, такими как С++ стандарта 20, С\#, JavaScript,
	Go и многие другие. Эти языки используют различные подходы к реализации сопрограмм. В следущих разделах 
	рассмотрим способы переключения в управляемых средах.
	
	\subsection{JavaScript и C\#}
	В JavaScript для работы с асинхронным вводом выводом введен класс Promise.
	Он представляет собой обёртку для значения, неизвестного на момент создания объекта. 
	Promise позволяет обрабатывать результаты асинхронных операций так, как если бы они были синхронными:
	вместо результата асинхронного метода возвращается обещание получить результат в будущем.
	Для удобной работы с Promise (c Task в случае С\#), существует специальный синтаксис, который называется «async/await». 
	
	\begin{lstlisting}
		async function f() {
			return 100;
		}
	\end{lstlisting}

	Ключевое слово async перед функцией означает, что функция всегда возвращает Promise.
	
	\begin{lstlisting}
		let value = await promise;
	\end{lstlisting}
	Ключевое слово await заставляет ждать, пока Promise не исполнится, и возвращает результат операции. Это работает только в функциях, помеченных ключевым словом async. 
	\par
	Строго говоря, блоки async/await не являются сопрограммаами, так как они были определены ранее. У таких сопрограмм нет отдельного
	стека, нет контекста, и реализуются они следующим образом. Компилятор языка превращает каждую конструкцию async/await
	в конечный автомат.
	
	Механизм async/await позволяет писать масштабируемый синхронный код и решает проблему контекста, вводя
	его	новый вид, который представляет собой поток во всем, но несовместим с потоками операционной
	системы. Синхронный и асинхронный код обычно не могут быть смешаны в одином блоке кода, и в
	результате языки с поддержкой async/await требуют два разных API для приостановки выполнения async
	блока кода и текущего потока. В Kotlin существует таже самая проблема: один API предназначен для
	приостановки потока, а другой для остановки новой конструкции, которая похожа на поток, но не
	является им.
	
	\subsection{Язык Go}
	Сопрограммы в Go еще называют горутинами. Это функции, которые запускаются конкурентно с другими функциями. 
	При запуске новой сопрограммы нужно перед вызываемой функцией вставить ключевое слово \textbf{go}.
	
	\begin{lstlisting}
	package main
	import "fmt"
	
	func foo() {
		fmt.Println("Foo called.")
	}
	func bar() {
		fmt.Println("Bar called.")
	}
	func main() {
		go foo()
		go bar()
	}

	\end{lstlisting}
		
	Эта программа содержит 3 сопрограммы. Первая - это функция main, являющаяся
	неявной сопрограммой. Вторая и третья это foo и bar. Обычно при вызове функции, наша программа 
	выполняет все ее операторы, а затем возвращает управление на следующую строку после вызова. 
	С помощью сопрограммы управление немедленно переходит к следующей строке без необходимости дожидаться завершения функции. Cреда исполнения языка не позволяет использовать потоки операционной системы
	напрямую. Разрешается создавать только сопрограммы.
	\par
	Язык Go, начиная с версии 1.3 использует непрерывный стек корутин. В прологе вызываемой функции вставляется проверка,
	что текущего размера стека будет достаточно для исполнения кода. Если старый стек слишком мал,
	то выделяется память под новый стек и содержимое старого копируется в новый. Имеющиеся указатели на
	данные в с стеке изменяются на новые. Данная реализация позволяет иметь небольшие стеки порядка 4--8 кБ, которые
	могут расти в неограниченных пределах. Но проверка выхода за границы размера в прологе дает накладные расходы,
	что является минусом.
	\par 
	Механизм переключение контекста сопрограммы в языке Go похож на переключения потоков[kernel.org???]:
	сохраняются в отдельный буфер необходимые регистры и информация, характерная только для данного
	потока/горутины, а затем в указатель стека записывается другой адрес. Но в отличии от потоков, 
	при переключении сопрограммы Go выполняется меньше операций и сохраняются не все регистры\cite{go-context}.
	
	\subsection{Проект "Loom"}
	В текущей версии языка Java - JDK16, поддержка сопрограмм отсутствует. Но с конца 2017 года ведется 
	работа в этом направлении проектом "Loom". Он направлен на сокращение усилий по написанию, поддержке
	высокопроизводительных параллельных приложений, которые максимально используют доступное оборудование\cite{loom-main}.
	\par
	Сопрограммы Loom - это виртуальные потоки, создание и блокировка которых требует меньше накладных расходов\cite{loom-main}. Они управляются средой исполнения языка Java. 
	В отличие от представленных в стандартной библиотеке потока "java.lang.Thread", виртуальные потоки не являются
	оболочками потоков ОС, а реализованы в JDK.
	
	\par
	Loom использует другой подход к переключению сопрограмм, отличающийся от языка Go. Когда сопрограмма начинает
	свою работу, она использует стек потока, на котором она запущена. При переключении сопрограммы происходит
	копирование части стека, используемой сопрограммой, в отдельный буфер памяти. Если нужно передать 
	управление обратно в сопрограмму, то происходит опустошение буфера и копирование его содержимого на 
	вершину стека потока\cite{loom-main}. Такая техника выбрана в целях совместимости со всеми существующими 
	сборщиками мусора, которые есть в OpenJDK. Некоторые из них не могут поддерживать объекты на куче, которые
	могут хранить ссылки по смещениям в памяти, меняющиеся на протяжении всего времени существования объекта
	на куче.

	\subsection{Применение сопрограмм}
	Сопрограммы имеют ряд практических применений. При появлении они использовались как средство
	для создания генераторов, итераторов, бесконечных списков и так далее. 
	
	C недавнего времени, более эффективный механизм сопрограмм рассматривается
	как альтернатива потокам в параллельных системах, что позволяет увеличить количество исполняемых
	задач в несколько раз. Это может быть полезно для создания систем обработки огромного объема данных.
	\par
	Сопрограммы подходят для работы со множеством относительно независимых задач.
	\par
	Рассмотрим на примере http-сервера. Каждый из запросов, которые он обслуживает, в значительной
	степени независим от других. Для каждого из них выполняется синтаксический анализ пакета, делается
	запрос к базе данных и/или к другому серверу, формируется ответ, который отправляется в клиенту. 
	Каждый запрос не взаимодействует с другими одновременными HTTP-запросами, но они конкурирует с ними за процессорное время и ресурсы ввода-вывода.
	Другими словами, http-сервер имеет некоторые единицы параллелизма домена приложения, 
	специфичные для его области, причем исполнение некоторой задачи выполняется независимо от другой в
	то же время. В данном случае единицей параллелизма является http-запрос. Для базы данных это может
	быть транзакция.
	\par
	Проблема заключается в том, что поток, не может соответствовать масштабу единиц параллелизма домена приложения.
	Потенциально сервер может обрабатывать до миллиона
	одновременных открытых сокетов, но операционная система не может эффективно обрабатывать более нескольких
	тысяч не бездействующих потоков.
	\par
	Сопрограммы позволяют избежать такую проблему. В силу своих преимуществ, их может быть
	созданно несколько миллионов, в то время как операционная система может поддерживать всего 
	лишь несколько тысяч активных потоков. В добавок они уменьшают время отклика сервера из--за
	большей скорости переключения.
	\par
	Кроме того, сопрограммы позволяют легко организовать работу с асинхронным  кодом.
	Неблокирующие операции, в том числе и асинхронный ввод--вывод, строится на обратных обработчиках.
	Когда такого кода очень много, его становится очень трудно отлаживать и исправлять.
	Сопрограммы помогают избежать такой проблемы, представляя список обработчиков как
	последовательный кусок кода.
	
\clearpage