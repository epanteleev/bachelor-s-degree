\section{Описание решения}
	
	\subsection{Разработка тестов}
	Пред началом реализации сопрограмм в Excelsior RVM были разработаны тесты производительности для языков Go и
	ранней версией проекта "Loom". 
	
	Todo
	
	\subsection{Переключение сопрограмм в HuaweiJDK}
	В таблице \ref{switch-table0} показаны результаты измерений скорости переключения сопрограмм Go и 
	OpenJDK/Loom\footnote{все измерения проводились на операционной системе Ubuntu, kernel 4.15, Intel Core i7-8700, 4.6 ГГц, 32 Гб ОЗУ}. 
	Видно, что сопрограммы из языка Go выигрывают OpenJDK в скорости переключения.
	
	\begin{table}[H]
		\caption{Число переключений сопрограмм}\label{switch-table0}
		\textit{\begin{tabular}{|c|c|c|c|c|c|}
				\hline \multirow{2}{*}{Шт.} & \multicolumn{2}{|c|}{Переключений, тыс./сек.}                     \\
				\cline{2-3}               & OpenJDK/"Loom"                         & Go                  	    \\
				\hline 100                & \numprint{1900} $\pm$ 20\phantom{0}    & \numprint{18187} $\pm$ 219 \\
				\hline \numprint{1000}    & \numprint{1775} $\pm$ 20\phantom{0}    & \numprint{17934} $\pm$ 332 \\
				\hline \numprint{5000}    & \numprint{1703} $\pm$ 30\phantom{0}    & \numprint{12892} $\pm$ 339 \\  
				\hline \numprint{10000}   & \numprint{1924} $\pm$ 235   		   & \numprint{8307} $\pm$ 80   \\  
				\hline \numprint{20000}   & \numprint{1863} $\pm$ 217   		   & \numprint{7045} $\pm$ 72   \\ 
				\hline \numprint{30000}   & \numprint{1772} $\pm$ 182   		   & \numprint{6391} $\pm$ 94   \\ 
				\hline \numprint{40000}   & \numprint{1606} $\pm$ 194              & \numprint{5790} $\pm$ 67   \\ 
				\hline \numprint{50000}   & \numprint{1503} $\pm$ 157   & \phantom{0}\numprint{5292} $\pm$ 122  \\  
				\hline 
		\end{tabular}}
	\end{table}
	
	Поэтому, для реализации в HuaweiJDK был выбран подход языка Go. Из-за простоты использования, в раннем
	прототипе для переключения контекста использовались функции из библиотеки glibc getcontext и swapcontext.
	Результат измерения раннего прототипа приведен в таблице \ref{switch-table-huaweiJDK}.

	\begin{table}[H]
		\caption{Число переключений сопрограмм}\label{switch-table-huaweiJDK}
		\textit{\begin{tabular}{|c|c|c|c|c|c|}
				\hline \multirow{2}{*}{Шт.} & \multicolumn{1}{|c|}{Переключений, тыс./сек.}                  \\
				\cline{2-2}               & HuaweiJDK                 \\
				\hline 100                & \numprint{1956} $\pm$ 38  \\
				\hline \numprint{1000}    & \numprint{1829} $\pm$ 12  \\
				\hline \numprint{5000}    & \numprint{1578} $\pm$ 39  \\  
				\hline \numprint{10000}   & \numprint{1316} $\pm$ 20  \\  
				\hline \numprint{20000}   &  1226 $\pm$ 8\phantom{0}  \\ 
				\hline \numprint{30000}   &  1068 $\pm$ 7\phantom{0}  \\ 
				\hline \numprint{40000}   &              928 $\pm$ 7  \\ 
				\hline \numprint{50000}   &              881 $\pm$ 5  \\  
				\hline 
		\end{tabular}}
	\end{table}	
	
	Анализ исходного кода функции swapcontext показал, что переключение можно ускорить. 
	Она используется для переключения потоков в операционных системах на ядре Linux[ref].
	Функция getcontext предоставляет информацию о пользовательском контексте, 
	описывающую состояние потока перед активацией обработчика сигнала, в том числе и 
	предшествующую маску сигналов и сохраненные значения регистров, в частности, программный счетчик и указатель
	стека\cite{linux-api}.
	Функция swapcontext предварительно делает системный вызов для сохранения текущей маски сигналов потока,
	в чем нет необходимости при переключении контекста сопрограмм. Это один из факторов, побудивший
	реализовать аналоги функций getcontext, swapcontext внутри HuaweiJDK, которые бы учитывали особенности виртуальной
	машины. На таблице \ref{huaweiJDK-cmp} представлено сравнение результатов скоростей переключения.  
	\begin{table}[H]
	\caption{Сравнение числа переключений}\label{huaweiJDK-cmp}
	\textit{\begin{tabular}{|c|c|c|c|c|c|}
			\hline \multirow{2}{*}{Шт.} & \multicolumn{2}{|c|}{Число переключений, тыс./сек.}   \\
			\cline{2-3}    		   		& getcontext/setcontext    & Функции из HuaweiJDK       \\
			\hline 100     		   		& \numprint{1956} $\pm$ 38 & \numprint{12980} $\pm$ 540 \\
			\hline \numprint{1000} 		& \numprint{1829} $\pm$ 12 & \numprint{11420} $\pm$ 694 \\
			\hline \numprint{5000} 		& \numprint{1578} $\pm$ 39 & \phantom{0}\numprint{5875} $\pm$ 183  \\
			\hline \numprint{10000}		& \numprint{1316} $\pm$ 20 & \phantom{0}\numprint{4459} $\pm$ 162  \\ 
			\hline \numprint{20000}		& 1226 $\pm$ 8\phantom{0}  & \numprint{3604} $\pm$ 93   \\ 
			\hline \numprint{30000}		& 1068 $\pm$ 7\phantom{0}  & \numprint{3031} $\pm$ 94   \\ 
			\hline \numprint{40000}		& 928 $\pm$ 7    		   & \numprint{2653} $\pm$ 87   \\ 
			\hline \numprint{50000}		& 881 $\pm$ 5    		   & \numprint{2315} $\pm$ 60   \\ 
			\hline 
		\end{tabular}
	}
	\end{table}
	Видно, что функции из glibc проигрывают в несколько раз при любом количестве сопрограмм.
	\subsection{Сборка мусора}
	Следущим шагом работы стала сборка мусора объектов, расположенных в зоне видимости функций,
	вызванных в сопрограмме. Виртуальная машина Java хранит список начал и вершин всех потоков,
	созданных в процессе работы.
	Это необходимо для того, чтобы при сборке мусора стало возможным нахождение всего
	корневого множества живых объектов. 
	\par
	В случае сопрограмм необходимо повторить данную логику: требуется хранить все адреса начал и вершин в некотором
	буфере. Но в отличии от потоков, нужно еще сохранять регистры приостановленных сопрограмм для корректной сборки. 
	
	\subsection{Потребление памяти}
	После реализации базового прототипа, наступил этап измерения потребления физической памяти. 
		
	\begin{table}[H]
		\caption{Измерение потребления физической памяти}\label{huaweiJDK-cmp}
		\textit{\begin{tabular}{|c|c|c|c|c|c|}
				\hline \multirow{2}{*}{Шт.} & \multicolumn{3}{|c|}{Резидентная память}  \\
				\cline{2-4}    & HuaweiJDK   & OpenJDK/"Loom"    & Go        \\
				\hline 100     & 18 Mб       & 130 Mб    		 & 3,040  Mб \\
				\hline 1000    & 22 Mб       & 161 Mб     		 & 3,105 Mб  \\
				\hline 5000    & 32 Mб       & 187 Mб    		 & 3,156 Mб  \\
				\hline 10000   & 37 Mб       & 193 Mб     		 & 3,308 Mб  \\
				\hline 20000   & 45 Mб       & 196 Mб     		 & 3,320 Mб  \\
				\hline 30000   & 49 Mб       & 197 Mб     		 & 3,350 Mб  \\
				\hline 40000   & 51 Mб       & 200 Mб    		 & 3,390 Mб  \\
				\hline 50000   & 57 Mб       & 202 Mб    		 & 3,407 Mб  \\ 
				\hline 
		\end{tabular}}
	\end{table}
	
	\begin{table}[H]
		\caption{Сравнение потребления памяти сопрограмм и потоков.}\label{inc-matrix}
		\textit{\begin{tabular}{|c|c|c|c|c|c|}
				\hline \multirow{2}{*}{Шт.} & \multicolumn{2}{|c|}{Размер физической памяти}  \\
				\cline{2-3}    & Сопрограммы   & Потоки    \\
				\hline 100     & 18 Mб         & 34 Mб     \\
				\hline 1000    & 22 Mб         & 35 Mб     \\
				\hline 5000    & 32 Mб         & 37 Mб     \\
				\hline 10000   & 37 Mб         & 40 Mб     \\
				\hline 20000   & 45 Mб         & 49 Mб     \\
				\hline 30000   & 49 Mб         & 56 Mб     \\
				\hline 40000   & 51 Mб         & 63 Mб     \\
				\hline 50000   & 57 Mб         & 72 Mб     \\ 
				\hline 
		\end{tabular}}
	\end{table}
 
	
\clearpage
